var sharp = require('sharp');
var stream = require('stream');
var Whammy = require('node-whammy');
var raf = require('raf');
var Canvas = require("canvas");
 

      var ctx = new Canvas(350, 500).getContext('2d');
      var lines = [
          [10, 10, 10, 300],
          [10, 10, 300, 10],
          [10, 300, 300, 400],
          [300, 10, 300, 400],
          [100, 10, 200, 150]
        ];
      for(var brad = 32, bx = 100, by = 100, i = 0, pf = Math.PI/8; i < 2 * Math.PI; i+= pf){
        lines.push([
            bx + brad * Math.cos(i),
            by + brad * Math.sin(i),
            bx + brad * Math.cos(i - pf),
            by + brad * Math.sin(i - pf)
          ])
      }
      var x = 50, y = 50;
      var vx = 0, vy = 0;
      var r = 10;
      function frame(id, callback){
        ctx.fillStyle = 'white'
        ctx.fillRect(0,0,1000,1000)
        ctx.fillStyle = 'black'
        //ctx.clearRect(0,0,1000,1000);
        ctx.beginPath();
        x += vx;
        y += vy;
        vy += 0.1; //gravity
        for(var i = lines.length; i--;){
          var l = lines[i];
          ctx.moveTo(l[0], l[1]);
          ctx.lineTo(l[2], l[3]);
          //var lt = Math.atan2(l[3] - l[1], l[2] - l[0])
          var a1 = -vy, b1 = vx;
          var a2 = -(l[1] - l[3]), b2 = l[0] - l[2];
          var c1 = a1 * x + b1 * y;
          var c2 = a2 * l[0] + b2 * l[1];
          var ix = (b2 * c1 - b1 * c2)/(a1 * b2 - a2 * b1);
          //var iy = (b2 * c1 - b1 * c2)/(a1 * b2 - a2 * b1);//(c1 - a1 * ix)/b1;
          var iy = (c1 * a2 - a1 * c2)/(b1 * a2 - a1 * b2);
          //a1 * x + b1 * y = c1
          //a2 * x + b2 * y = c2
          /*
          for(var k = 0; k < 200; k++){
            ctx.fillRect(k, (c1 - a1 * k)/b1, 2, 2);    
          }
          for(var k = 0; k < 200; k++){
            ctx.fillRect(k, (c2 - a2 * k)/b2, 2, 2);    
          }
          */
          //console.log(ix, iy);
          //ctx.fillRect(ix - 2, iy - 2, 4, 4);
          ctx.moveTo(x, y);
          //ctx.lineTo(x + , iy);
          //console.log(ix, iy)
          //ctx.moveTo(x, y);
          //ctx.lineTo(x + vx * 30, y + vy * 30);
          //todo: extend each line by a unit vector before testing
          var xx = Math.max(l[0], l[2]) + 1, nx = Math.min(l[0], l[2]) - 1;
          var xy = Math.max(l[1], l[3]) + 1, ny = Math.min(l[1], l[3]) -1 ;
          if(ix > x == vx > 0 && iy > y == vy > 0){
            //console.log('directionality passed');
            if(ix <= xx && ix >= nx && iy <= xy && iy >= ny){
              //console.log('bounding intercept passed');
              var d2 = (ix - x) * (ix - x) + (iy - y) * (iy - y);
              var mag = Math.sqrt(vx*vx + vy * vy);
              ctx.fillRect(ix - 2, iy - 2, 4, 4);
              if(Math.sqrt(d2) <= (r + mag + 1)){
                //console.log('distance passed');
                //rotate
                //console.log('carl sagan');
                var la = Math.atan2(l[3] - l[1], l[2] - l[0]);
                var ba = Math.atan2(vy, vx);
                var da = 2 * la - ba;
                //da = 2 * la - da;
                //if(i == 2) mag += (Math.random() - 0.5);
                //mag *= 0.99;
                vx =  mag * Math.cos(da);
                vy = mag * Math.sin(da);
                //console.log(mag)
                //break;
                //console.log(vx, vy);
              }
            }
          }
        }
        var mag = Math.sqrt(vx*vx + vy * vy);
        //ctx.fillRect(0, 0, mag * 10, 20);
        //ctx.fillRect(0, 20, 5 * Math.sqrt(vx * vx + vy * vy + 500 - y), 20);
        //ctx.fillRect(0, 40, Math.abs(vy * 10), 20);
        ctx.moveTo(x + r,y);
        ctx.arc(x,y,r,0,Math.PI*2,false);
        
        ctx.stroke();
        canvasToWebp(ctx.canvas, function(webmData) {
            callback(id, webmData);
        });
        // return ctx.canvas.toDataURL('image/webp', 0);
      }

var frames = 150;




var start = Date.now();
var images = [];
var loopnum = 0;
var video = null;
var identifier = 0;
function addFrame(){
  frame(++identifier, function(id, webpData) {
      images.push(webpData);
      if(loopnum == frames && identifier == id) {
        var timeElapsed = Date.now() - start;
        var fps = frames / (timeElapsed / 1000);
        video = Whammy.fromImageArray(images, fps, true);
        // console.log(video);
        console.log("Ready!");
      }
  });
  
  if(loopnum != frames){
    loopnum++;
    //setTimeout(addFrame, 100)
    raf(addFrame);
  }
}

addFrame();


function canvasToWebp(canvas, callback) {

    sharp(canvas.toBuffer()).toFormat(sharp.format.webp).toBuffer(function(e, webpbuffer) {
        var webpDataURL = 'data:image/webp;base64,' + webpbuffer.toString('base64');
        callback(webpDataURL);
    });

}

function sendAsWEBP(response, canvas) {
    var encoder = new Whammy.Video(7);
    
    var currentId = 0,
        time = 0,
        timeout = 20000,
        delay = 20,
        addedFrame = -1,
        totalFrames = 3,
        tmpFrames = Array.apply(null, Array(totalFrames));
    // Initiate the source
    var bufferStream = new stream.PassThrough();
    
    var addFrame = function (context) {
        var id = currentId++;
        canvasToWebp(context.canvas, function(webmData) {
            tmpFrames[id] = webmData;
            for(var i = addedFrame + 1; i < totalFrames; ++i) {
                if(tmpFrames[i] !== undefined) {
                    encoder.add(tmpFrames[i]);
                    addedFrame = i;
                }
                else break;
            }
        });
    };
    
    
    var checkReady = function checkReady() {
        if(totalFrames <= addedFrame + 1) {
            try {
                var output = encoder.compile(true);
                console.log(totalFrames);
                // response.type('webm');
                bufferStream.write(new Buffer(output));
                // bufferStream.pipe(response);
                //response.send(new Buffer(output));
                console.log('Webm compilation: ' + time + 'ms');
            }
            catch(err) {
                console.log(err.toString());
            }
        }
        else if((time += delay) < timeout) {
            setTimeout(checkReady, delay);
        }
        else {
            response.send('Timeout of ' + timeout + 'ms exceed');
        }
    };
    
    var context = canvas.getContext("2d");
    
    // Add 3 frames
    addFrame(context);
    addFrame(context);
    addFrame(context);
    
    setTimeout(checkReady, delay);
    return bufferStream;
}

//Lets require/import the HTTP module
var http = require('http');
var fs = require("fs");
var path = require("path");

//Lets define a port we want to listen to
const PORT=process.env.PORT; 

function handleRequest(request, response){
    if (request.url != "/small.webm") {
        response.writeHead(200, { "Content-Type": "text/html" });
        response.end('<video src="/small.webm" controls></video>');
    } else {
        // var file = path.resolve(__dirname,"small.webm");
        var range = request.headers.range;
        var positions = range.replace(/bytes=/, "").split("-");
        var start = parseInt(positions[0], 10);
        // fs.stat(file, function(err, stats) {
            var total = parseInt(video.length/100, 10); //stats.size;
            var end = start + (positions[1] ? parseInt(positions[1], 10) : total - 1);
            var chunksize = (end - start) + 1;
            console.log(range);
            console.log(start + "-" + end + "/" + (start + total));
            
            response.writeHead(206, {
                "Content-Range": "bytes " + start + "-" + end + "/" + (start+total+10),
                "Accept-Ranges": "bytes",
                "Content-Length": chunksize,
                "Content-Type": "video/webm",
                'Transfer-Encoding':'chunked'
            });
            
            // var s = new stream.PassThrough()//sendAsWEBP(response, new Canvas(200, 200))//fs.createReadStream(file, { start: start, end: end })
            //     .writeHead(206, {
            //         "Content-Range": "bytes " + start + "-" + end + "/" + total,
            //         "Accept-Ranges": "bytes",
            //         "Content-Length": chunksize,
            //         "Content-Type": "video/webm"
            //     }).on("open", function() {
            //         s.pipe(response);
            //     }).on("error", function(err) {
            //         response.end(err);
            // });
            // console.log(video.slice(start, end));
            // for(var i in video)
                response.write(new Buffer(video.slice(start, end+1)));
        // });
        //sendAsWEBP(response, new Canvas(200, 200));
    }
    // response.end('It Works!! Path Hit: ' + request.url);
}

//Create a server
var server = http.createServer(handleRequest);

//Lets start our server
server.listen(process.env.PORT || 3000, process.env.IP || "0.0.0.0",  function(){
	var addr = server.address();
	console.log("Gaas server listening at", addr.address + ":" + addr.port);
});