
var vm = module.require("vm");
var fs = module.require("fs");
var DOM = module.require("./DOM");
var requestAnimationFrame = module.require("raf");
// var script = vm.createScript( process.argv[2] );
// var obj = { sendResult:function (result) { process.send(result); process.exit(0); } };
// var context = vm.createContext(obj);

// process.send("test");
// // script.runInNewContext(context);

// process.on('uncaughtException', function(err) {
//     process.exit(1);
// });


function readSourceFiles(path, callback) {
    fs.readdir(path + '/source', function (err, files) {
        if (err) throw err;
        var src = [];
        var nonJSFileCount = 0;
        for(var i = 0; i < files.length; i++) {
            var srcName = files[i];
            
            if(srcName.indexOf('.') == -1) {
                nonJSFileCount++;
                continue;
            }
            var postFix = srcName.substr(srcName.lastIndexOf(".")+1);
            if(postFix != 'js' && postFix != 'json') {
                nonJSFileCount++;
                continue;
            }
            fs.readFile(path + '/source/' + srcName, function (err, data) {
                if(err) throw err;
                // src.push({name: srcName, data: data});
                src.push(data);
                if(src.length + nonJSFileCount >= files.length && typeof(callback) == "function")
                    callback(src);
            });
        }
    });
}

if(process.argv.length > 2) {
    try {
        var options = JSON.parse(process.argv[2]);
        readSourceFiles(options.sourcePath, function(sources) {
            var currentDir = process.cwd();
            process.chdir(currentDir + '/' + options.sourcePath + '/source');
            var initScript = fs.readFileSync('../init.js', 'utf8');
            sources.push(initScript);
            var holeScript = sources.join("\n\n");
            var thisScope = new DOM(options.width || 200, options.height || 300);
            process.on('message', function(event) {
                thisScope.do(event.type, event);
            });
            // for(var i = 2; i < sources.length; i++) {
            //     vm.runInNewContext(vm.createScript(sources[i].data), thisScope);
            // }
            // console.log(thisScope);
            // process.chdir(currentDir);
            vm.runInNewContext(holeScript, thisScope);
            
            // Start the game
            process.send({what:'gameStart'});
            
            
            var ticksPerSecond = 1000 / 20; // ms / fps
            var lastRenderedFrame = 0;
            var params = {
                q: 20,
                f: 'png',
                g: 1,
                w: 0
               // Foramt=f, Quality=q, gamers=g and watcher=w 
            };
            var Time = require('./Time');
            var nameLatencyId = Time.getFileName('mario', 'Latency', params);
            var namePackageId = Time.getFileName('mario', 'Package', params);
            (function gameLoop(timelapsed) {
            	var delta = timelapsed - lastRenderedFrame;
            	if(ticksPerSecond < delta) {
                    if(thisScope.__elements.length > 0) {
                        var canvas = thisScope.__elements[0]; // TODO: check if canvasIdentirifer is present in meta data of the game
                        var clock = Time.start(nameLatencyId);
                        console.log('image/' + params.f, params.q/100);
                        canvas.toDataURL('image/' + params.f, /*params.q/100,*/ function(err, image) {
                            Time.stop(nameLatencyId);
                            if(clock.instances.length >= 100) {
                                Time.storeMeasureTime(nameLatencyId, params.q);
                                if(params.q > 100) process.exit(0);
                                params.q += 5;
                            }
                            //Time.count(namePackageId, Buffer.byteLength(image, 'utf8'));
                            process.send({
                                what: 'frame', delta: delta, 
                                canvasData: image
                            });
                        });
                            // toDataURL('image/webp', quality)
                            // toDataURL('image/jpeg', quality)
                            // toDataURL('image/png')
                            // toBuffer()
            		}
            		lastRenderedFrame = timelapsed;
            	}
                requestAnimationFrame(gameLoop);
            })();
        });
    }
    catch(e) {
        process.exit(1);
    }
}